<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows内核研究</title>
    <url>/2021/01/29/Windows%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>关于 Windows 内核的学习，也学习了一段时间了，没有详细的做笔记，至此准备详细的做一下笔记，并以博客的方式分享出来。</p>
<a id="more"></a>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><ul>
<li><a href="/2021/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%9F">什么是保护模式？</a></li>
<li><a href="/2021/01/29/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84">段寄存器结构</a></li>
</ul>
]]></content>
      <categories>
        <category>Windows内核研究</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>利用ESP8266制作WIFI杀手</title>
    <url>/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/</url>
    <content><![CDATA[<h1 id="什么是ESP8266？"><a href="#什么是ESP8266？" class="headerlink" title="什么是ESP8266？"></a>什么是ESP8266？</h1><p>ESP8266是基于Arduino开发的单片机，简单来说就是一个WIFI物联网模块，实际应用很广。而且技术成熟，成本低廉，也就十几块钱的事。</p>
<a id="more"></a>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/1.jpg" width="50%" height="50%">

<h1 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li>ESP8266 NodeMCU CH340（淘宝）</li>
<li>Micro USB 数据线</li>
</ul>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>ESP8266Flasher：<a href="https://github.com/nodemcu/nodemcu-flasher">https://github.com/nodemcu/nodemcu-flasher</a> （有x32 x64两种版本根据自己的电脑系统）</li>
<li>esp8266_deauther：<a href="https://github.com/SpacehuhnTech/esp8266_deauther/releases">https://github.com/SpacehuhnTech/esp8266_deauther/releases</a> （根据自己的需求选择对因的固件）</li>
</ul>
<h1 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h1><p>首先我们先把板子连接好，然后打开 ESP8266Flasher。</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/2.png" width="50%" height="50%">

<p>打开后一般都自动识别到端口号，如果没有识别出来可以试试，重新拔插一下板子或者手动安装一下板子的驱动。（安装驱动这里就不阐述了）<br>识别到端口号后，我们就可以点击 Config 栏选择esp8266_deauther固件了。</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/3.png" width="50%" height="50%">

<p>选择完固件后，我们还要到 Advanced 栏设置一下属性</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/4.png" width="50%" height="50%">

<p>这样配置完，我们就可以开始烧录固件了。返回到 Operation 栏，点击 Flash，等待烧录完毕即可。（在烧录的过程中，板子上的 LED 是会闪烁的）</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/5.png" width="50%" height="50%">

<p>这样就烧录完毕了</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/6.png" width="50%" height="50%">

<h1 id="deauther-简单使用"><a href="#deauther-简单使用" class="headerlink" title="deauther 简单使用"></a>deauther 简单使用</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>扫描WIFI</li>
<li><code>pwned</code> 使用密码连接 <code>deauther</code></li>
<li>浏览器访问 <code>192.168.4.1</code></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们先选择一个自家的WIFI，然后点击 Attack。</p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/7.png">

<p>我们在 Attack 页面点击 Deauth 栏 START。  </p>
<img src="/2021/01/27/%E5%88%B6%E4%BD%9CWIFI%E6%9D%80%E6%89%8B/8.png">

<p>这样就开始攻击 WIFI。<br>Deauth 这个功能会造成当前连接WIFI的所以设备断开连接。<br>deauther 固件的其他功能，可以在 WEB 页面里自己研究一下，这里就不阐述了。</p>
<h1 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h1><ul>
<li>如果对原理感兴趣的话，可以去看看 esp8266_deauther 的源码</li>
<li>WIFI 杀手，只能自己学习研究，不能用于非法活动。切记！切记！切记！</li>
</ul>
]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
  </entry>
  <entry>
    <title>什么是保护模式？</title>
    <url>/2021/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是保护模式？"><a href="#什么是保护模式？" class="headerlink" title="什么是保护模式？"></a>什么是保护模式？</h1><p>x86 CPU 有三个模式。分别为：实模式、保护模式、虚拟8086模式</p>
<h1 id="保护模式有什么特点？"><a href="#保护模式有什么特点？" class="headerlink" title="保护模式有什么特点？"></a>保护模式有什么特点？</h1><p>段机制<br>页机制</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>《Intel 白皮书》</p>
]]></content>
      <categories>
        <category>Windows内核研究</category>
      </categories>
  </entry>
  <entry>
    <title>段寄存器结构</title>
    <url>/2021/01/29/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>保护模式有两大机制：段和页<br>想了解段机制就要先了解 <font color="RED">段寄存器</font></p>
<a id="more"></a>

<h1 id="什么是段寄存器？有哪几个？"><a href="#什么是段寄存器？有哪几个？" class="headerlink" title="什么是段寄存器？有哪几个？"></a>什么是段寄存器？有哪几个？</h1><p>当我们用汇编读写内存的时候：<br><code> mov eax, dword ptr ds:[0x12345678], eax </code><br>这里其实读写的真实地址是：ds.base + 0x12345678</p>
<p>ES CS SS DS FS GS LDTR TR 共8个段寄存器。</p>
<h1 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	WORD Selecter;     <span class="comment">//16位 Selecter    //可看见部分，通过这个字段查表读其他字段</span></span><br><span class="line">	WORD Attribute;    <span class="comment">//16位 Attribute</span></span><br><span class="line">	DWORD Base;        <span class="comment">//32位 Base</span></span><br><span class="line">	DWORD Limit;       <span class="comment">//32位 Limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h1><h2 id="读段寄存器"><a href="#读段寄存器" class="headerlink" title="读段寄存器"></a>读段寄存器</h2><p>比如：<code>mov ax, ds</code> 只能读可见的16位<br>读写LDTR的指令：SLDT/LLDT<br>读写TR的指令：  STR/LTR</p>
<h2 id="写段寄存器"><a href="#写段寄存器" class="headerlink" title="写段寄存器"></a>写段寄存器</h2><p>比如：<code>mov ds, ax</code> 其实，也是只能写16位<br>但是，重新写入的话，段寄存器查表读到的字段就可能不一样了。</p>
<h1 id="段选择子（SegMent-Selecter）"><a href="#段选择子（SegMent-Selecter）" class="headerlink" title="段选择子（SegMent.Selecter）"></a>段选择子（SegMent.Selecter）</h1><img src="/2021/01/29/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84/1.png">

<p>Selecter 的结构如上。<br>前面说到段寄存器的其他字段是通过<code>Selecter</code>查表读到的数据<br><code>Selecter.index</code> 这个值就是在表中索引（类似数组的索引）<br><code>Selecter.TI</code>    这个值说明当前的段寄存器要查哪张表（GDT / LDT，后面的文章中解释）<br><code>Selecter.RPL</code>   请求特权等级，后面的文章中解释。</p>
]]></content>
      <categories>
        <category>Windows内核研究</category>
      </categories>
  </entry>
</search>
